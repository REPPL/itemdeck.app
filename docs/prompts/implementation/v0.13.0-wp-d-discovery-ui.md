# Work Package D: Plugin Discovery UI

## Overview

Create the user interface for browsing, installing, and managing plugins.

**Version:** v0.13.0
**Dependencies:** WP-A (Plugin Core) must be complete
**Estimated Scope:** ~10 new components, ~1500 lines of code

---

## Context

After WP-A completes, we have:
- Plugin manifest schemas
- Plugin store (Zustand)
- Plugin cache (IndexedDB)
- Plugin loader
- Security/sandbox system

This work package creates the UI to interact with that infrastructure.

---

## Objectives

1. Create plugin browser component
2. Create plugin card and detail views
3. Create plugin manager for installed plugins
4. Create permission dialogue for capability consent
5. Implement registry client for static JSON registry
6. Create React Query hooks for plugin data

---

## Technical Requirements

### 1. Plugin Browser

**Location:** `src/components/PluginBrowser/`

**Files:**
- `index.tsx` - Main browser component
- `PluginBrowser.module.css` - Styles
- `PluginFilters.tsx` - Filter controls
- `PluginSearch.tsx` - Search input

**Component Structure:**
```tsx
interface PluginBrowserProps {
  isOpen: boolean;
  onClose: () => void;
  initialFilter?: PluginType;
}

function PluginBrowser({ isOpen, onClose, initialFilter }: PluginBrowserProps) {
  // State for search, filters, pagination
  // Fetch plugins from registry
  // Render grid of PluginCards

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="Plugin Browser">
      <div className={styles.browser}>
        <div className={styles.sidebar}>
          <PluginSearch value={search} onChange={setSearch} />
          <PluginFilters
            type={typeFilter}
            onTypeChange={setTypeFilter}
          />
        </div>
        <div className={styles.content}>
          <div className={styles.grid}>
            {plugins.map(plugin => (
              <PluginCard
                key={plugin.id}
                plugin={plugin}
                onInstall={handleInstall}
                onViewDetails={handleViewDetails}
              />
            ))}
          </div>
          <Pagination
            page={page}
            totalPages={totalPages}
            onPageChange={setPage}
          />
        </div>
      </div>
    </Modal>
  );
}
```

**Features:**
- Search by name, description, keywords
- Filter by type (theme, mechanic, source)
- Sort by popularity, recent, name
- Pagination (20 per page)
- Loading and error states

---

### 2. Plugin Card

**Location:** `src/components/PluginCard/`

**Files:**
- `index.tsx` - Card component
- `PluginCard.module.css` - Styles

**Component Structure:**
```tsx
interface PluginCardProps {
  plugin: PluginSummary;
  installed?: boolean;
  onInstall: (pluginId: string) => void;
  onViewDetails: (pluginId: string) => void;
}

function PluginCard({ plugin, installed, onInstall, onViewDetails }: PluginCardProps) {
  return (
    <div className={styles.card} onClick={() => onViewDetails(plugin.id)}>
      <div className={styles.icon}>
        {plugin.iconUrl ? (
          <img src={plugin.iconUrl} alt="" />
        ) : (
          <PluginTypeIcon type={plugin.type} />
        )}
      </div>
      <div className={styles.content}>
        <h3 className={styles.name}>{plugin.name}</h3>
        <p className={styles.description}>{plugin.description}</p>
        <div className={styles.meta}>
          <span className={styles.author}>{plugin.author}</span>
          <span className={styles.version}>v{plugin.version}</span>
        </div>
      </div>
      <div className={styles.actions}>
        {installed ? (
          <Badge variant="success">Installed</Badge>
        ) : (
          <Button
            size="small"
            onClick={(e) => {
              e.stopPropagation();
              onInstall(plugin.id);
            }}
          >
            Install
          </Button>
        )}
      </div>
    </div>
  );
}
```

**Design:**
- Compact card layout
- Plugin icon (or type icon fallback)
- Name, description (truncated)
- Author and version
- Install button or "Installed" badge

---

### 3. Plugin Details

**Location:** `src/components/PluginDetails/`

**Files:**
- `index.tsx` - Details modal
- `PluginDetails.module.css` - Styles
- `PluginScreenshots.tsx` - Screenshot gallery
- `PluginCapabilities.tsx` - Capability list

**Component Structure:**
```tsx
interface PluginDetailsProps {
  pluginId: string;
  isOpen: boolean;
  onClose: () => void;
  onInstall: (pluginId: string) => void;
}

function PluginDetails({ pluginId, isOpen, onClose, onInstall }: PluginDetailsProps) {
  const { data: plugin, isLoading } = usePluginDetails(pluginId);
  const { data: installed } = useInstalledPlugins();
  const isInstalled = installed?.some(p => p.id === pluginId);

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="large">
      {isLoading ? (
        <LoadingSpinner />
      ) : plugin ? (
        <div className={styles.details}>
          <header className={styles.header}>
            <img src={plugin.iconUrl} alt="" className={styles.icon} />
            <div className={styles.info}>
              <h2>{plugin.name}</h2>
              <p className={styles.author}>by {plugin.author.name}</p>
              <div className={styles.stats}>
                <span>v{plugin.version}</span>
                <span>{plugin.downloads} downloads</span>
                <span>{plugin.rating} stars</span>
              </div>
            </div>
            <div className={styles.actions}>
              {isInstalled ? (
                <Button variant="secondary" disabled>Installed</Button>
              ) : (
                <Button onClick={() => onInstall(plugin.id)}>Install</Button>
              )}
            </div>
          </header>

          <PluginScreenshots screenshots={plugin.screenshots} />

          <section className={styles.description}>
            <h3>Description</h3>
            <Markdown>{plugin.readme || plugin.description}</Markdown>
          </section>

          <section className={styles.capabilities}>
            <h3>Permissions</h3>
            <PluginCapabilities capabilities={plugin.manifest.capabilities} />
          </section>

          <section className={styles.changelog}>
            <h3>Changelog</h3>
            <Markdown>{plugin.changelog}</Markdown>
          </section>
        </div>
      ) : (
        <ErrorMessage>Plugin not found</ErrorMessage>
      )}
    </Modal>
  );
}
```

**Sections:**
- Header with icon, name, author, stats
- Screenshots gallery
- Full description/README
- Required permissions
- Changelog
- Install/uninstall button

---

### 4. Plugin Manager

**Location:** `src/components/PluginManager/`

**Files:**
- `index.tsx` - Manager component
- `PluginManager.module.css` - Styles
- `InstalledPluginRow.tsx` - Row for each plugin
- `PluginSettings.tsx` - Per-plugin settings

**Component Structure:**
```tsx
function PluginManager() {
  const { data: plugins } = useInstalledPlugins();
  const { mutate: enablePlugin } = useEnablePlugin();
  const { mutate: disablePlugin } = useDisablePlugin();
  const { mutate: uninstallPlugin } = useUninstallPlugin();

  return (
    <div className={styles.manager}>
      <header className={styles.header}>
        <h2>Installed Plugins</h2>
        <Button onClick={openBrowser}>Browse Plugins</Button>
      </header>

      {plugins?.length === 0 ? (
        <EmptyState
          title="No plugins installed"
          description="Browse the plugin registry to find themes, games, and more."
          action={<Button onClick={openBrowser}>Browse Plugins</Button>}
        />
      ) : (
        <div className={styles.list}>
          {plugins?.map(plugin => (
            <InstalledPluginRow
              key={plugin.id}
              plugin={plugin}
              onEnable={() => enablePlugin(plugin.id)}
              onDisable={() => disablePlugin(plugin.id)}
              onUninstall={() => uninstallPlugin(plugin.id)}
              onConfigure={() => openSettings(plugin.id)}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

**InstalledPluginRow:**
```tsx
interface InstalledPluginRowProps {
  plugin: InstalledPluginInfo;
  onEnable: () => void;
  onDisable: () => void;
  onUninstall: () => void;
  onConfigure: () => void;
}

function InstalledPluginRow({ plugin, ...handlers }: InstalledPluginRowProps) {
  return (
    <div className={styles.row}>
      <div className={styles.info}>
        <span className={styles.name}>{plugin.name}</span>
        <span className={styles.version}>v{plugin.version}</span>
        <Badge variant={plugin.tier}>{plugin.tier}</Badge>
      </div>

      <div className={styles.controls}>
        <Toggle
          checked={plugin.enabled}
          onChange={plugin.enabled ? handlers.onDisable : handlers.onEnable}
          label={plugin.enabled ? 'Enabled' : 'Disabled'}
        />

        <IconButton
          icon="settings"
          onClick={handlers.onConfigure}
          aria-label="Configure plugin"
        />

        <DropdownMenu>
          <DropdownItem onClick={handlers.onUninstall}>
            Uninstall
          </DropdownItem>
        </DropdownMenu>
      </div>
    </div>
  );
}
```

**Features:**
- List of installed plugins
- Enable/disable toggle
- Configure button (opens settings)
- Uninstall option
- Empty state with CTA to browse
- Group by type (optional)

---

### 5. Permission Dialogue

**Location:** `src/components/PluginPermissionDialogue/`

**Files:**
- `index.tsx` - Dialogue component
- `PluginPermissionDialog.module.css` - Styles
- `CapabilityItem.tsx` - Individual capability row

**Component Structure:**
```tsx
interface PluginPermissionDialogProps {
  plugin: PluginManifest;
  requestedCapabilities: Capability[];
  onGrant: (capabilities: Capability[]) => void;
  onDeny: () => void;
}

function PluginPermissionDialog({
  plugin,
  requestedCapabilities,
  onGrant,
  onDeny,
}: PluginPermissionDialogProps) {
  const [selectedCapabilities, setSelectedCapabilities] = useState<Capability[]>(
    requestedCapabilities
  );

  return (
    <Dialog
      title="Permission Request"
      description={`${plugin.name} is requesting the following permissions:`}
    >
      <div className={styles.capabilities}>
        {requestedCapabilities.map(cap => (
          <CapabilityItem
            key={cap}
            capability={cap}
            checked={selectedCapabilities.includes(cap)}
            onChange={(checked) => {
              if (checked) {
                setSelectedCapabilities([...selectedCapabilities, cap]);
              } else {
                setSelectedCapabilities(selectedCapabilities.filter(c => c !== cap));
              }
            }}
          />
        ))}
      </div>

      <div className={styles.warning}>
        <WarningIcon />
        <p>
          Only grant permissions to plugins you trust.
          Community plugins run in a sandbox for your safety.
        </p>
      </div>

      <div className={styles.actions}>
        <Button variant="secondary" onClick={onDeny}>
          Deny
        </Button>
        <Button onClick={() => onGrant(selectedCapabilities)}>
          Grant Selected
        </Button>
      </div>
    </Dialog>
  );
}
```

**CapabilityItem:**
```tsx
interface CapabilityItemProps {
  capability: Capability;
  checked: boolean;
  onChange: (checked: boolean) => void;
}

function CapabilityItem({ capability, checked, onChange }: CapabilityItemProps) {
  const info = CAPABILITY_INFO[capability];

  return (
    <label className={styles.capability}>
      <Checkbox checked={checked} onChange={onChange} />
      <div className={styles.info}>
        <span className={styles.name}>{info.name}</span>
        <span className={styles.description}>{info.description}</span>
        <Badge variant={info.risk}>{info.risk} risk</Badge>
      </div>
    </label>
  );
}
```

**Capability Descriptions:**
```typescript
const CAPABILITY_INFO: Record<Capability, { name: string; description: string; risk: 'low' | 'medium' | 'high' }> = {
  'storage:local': {
    name: 'Local Storage',
    description: 'Store data in your browser',
    risk: 'low',
  },
  'fetch:external': {
    name: 'Network Access',
    description: 'Make requests to external servers',
    risk: 'high',
  },
  // ... etc
};
```

---

### 6. Registry Client

**Location:** `src/plugins/registry/registryClient.ts`

**Implementation:**
```typescript
interface RegistryConfig {
  baseUrl: string;
  cacheTime: number;
}

class PluginRegistry {
  private config: RegistryConfig;
  private cache: Map<string, { data: unknown; expires: Date }>;

  constructor(config?: Partial<RegistryConfig>) {
    this.config = {
      baseUrl: config?.baseUrl || 'https://raw.githubusercontent.com/itemdeck/plugins/main',
      cacheTime: config?.cacheTime || 5 * 60 * 1000, // 5 minutes
    };
    this.cache = new Map();
  }

  async listPlugins(options?: {
    type?: PluginType;
    search?: string;
    page?: number;
    limit?: number;
  }): Promise<PluginListResponse> {
    // Fetch plugins.json from registry
    const allPlugins = await this.fetchRegistry();

    // Apply filters
    let filtered = allPlugins;
    if (options?.type) {
      filtered = filtered.filter(p => p.type === options.type);
    }
    if (options?.search) {
      const search = options.search.toLowerCase();
      filtered = filtered.filter(p =>
        p.name.toLowerCase().includes(search) ||
        p.description.toLowerCase().includes(search) ||
        p.keywords?.some(k => k.toLowerCase().includes(search))
      );
    }

    // Paginate
    const page = options?.page || 1;
    const limit = options?.limit || 20;
    const start = (page - 1) * limit;
    const paginated = filtered.slice(start, start + limit);

    return {
      plugins: paginated,
      pagination: {
        page,
        limit,
        total: filtered.length,
        hasMore: start + limit < filtered.length,
      },
    };
  }

  async getPlugin(pluginId: string): Promise<PluginDetails> {
    // Fetch individual plugin manifest
    const manifest = await this.fetchManifest(pluginId);
    return {
      ...manifest,
      downloads: 0, // Static registry doesn't track downloads
      rating: 0,
    };
  }

  async fetchPlugin(pluginId: string): Promise<{
    manifest: PluginManifest;
    assets: Map<string, Blob>;
  }> {
    // Fetch plugin bundle
    const bundleUrl = `${this.config.baseUrl}/plugins/${pluginId}/bundle.zip`;
    const response = await fetch(bundleUrl);

    if (!response.ok) {
      throw new Error(`Failed to fetch plugin: ${response.statusText}`);
    }

    const bundle = await response.arrayBuffer();
    return this.extractBundle(bundle);
  }

  private async fetchRegistry(): Promise<PluginSummary[]> {
    const cacheKey = 'registry';
    const cached = this.cache.get(cacheKey);
    if (cached && cached.expires > new Date()) {
      return cached.data as PluginSummary[];
    }

    const response = await fetch(`${this.config.baseUrl}/plugins.json`);
    const data = await response.json();

    this.cache.set(cacheKey, {
      data: data.plugins,
      expires: new Date(Date.now() + this.config.cacheTime),
    });

    return data.plugins;
  }
}
```

**Initial plugins.json:**
```json
{
  "version": "1.0.0",
  "lastUpdated": "2024-12-28",
  "plugins": []
}
```

This will be populated as plugins are created.

---

### 7. React Query Hooks

**Location:** `src/plugins/hooks/`

**Files:**
- `usePlugins.ts` - Query hooks
- `useInstallPlugin.ts` - Mutation hooks

**usePlugins.ts:**
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

const pluginKeys = {
  all: ['plugins'] as const,
  list: (filters: PluginFilters) => [...pluginKeys.all, 'list', filters] as const,
  detail: (id: string) => [...pluginKeys.all, 'detail', id] as const,
  installed: () => [...pluginKeys.all, 'installed'] as const,
};

export function usePluginList(filters: PluginFilters = {}) {
  const registry = usePluginRegistry();

  return useQuery({
    queryKey: pluginKeys.list(filters),
    queryFn: () => registry.listPlugins(filters),
    staleTime: 5 * 60 * 1000,
  });
}

export function usePluginDetails(pluginId: string) {
  const registry = usePluginRegistry();

  return useQuery({
    queryKey: pluginKeys.detail(pluginId),
    queryFn: () => registry.getPlugin(pluginId),
    enabled: !!pluginId,
  });
}

export function useInstalledPlugins() {
  const store = usePluginStore();

  return useQuery({
    queryKey: pluginKeys.installed(),
    queryFn: () => Array.from(store.installedPlugins.values()),
  });
}
```

**useInstallPlugin.ts:**
```typescript
export function useInstallPlugin() {
  const queryClient = useQueryClient();
  const loader = usePluginLoader();
  const store = usePluginStore();

  return useMutation({
    mutationFn: async (params: { pluginId: string; tier: PluginTier }) => {
      const plugin = await loader.loadPlugin(
        { type: 'registry', id: params.pluginId },
        { autoEnable: true }
      );

      store.installPlugin(plugin.manifest, params.tier);
      return plugin;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: pluginKeys.installed() });
    },
  });
}

export function useUninstallPlugin() {
  const queryClient = useQueryClient();
  const loader = usePluginLoader();
  const store = usePluginStore();

  return useMutation({
    mutationFn: async (pluginId: string) => {
      await loader.disablePlugin(pluginId);
      await loader.cache.remove(pluginId);
      store.uninstallPlugin(pluginId);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: pluginKeys.installed() });
    },
  });
}

export function useEnablePlugin() {
  const queryClient = useQueryClient();
  const loader = usePluginLoader();
  const store = usePluginStore();

  return useMutation({
    mutationFn: async (pluginId: string) => {
      await loader.enablePlugin(pluginId);
      store.enablePlugin(pluginId);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: pluginKeys.installed() });
    },
  });
}

export function useDisablePlugin() {
  const queryClient = useQueryClient();
  const loader = usePluginLoader();
  const store = usePluginStore();

  return useMutation({
    mutationFn: async (pluginId: string) => {
      await loader.disablePlugin(pluginId);
      store.disablePlugin(pluginId);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: pluginKeys.installed() });
    },
  });
}
```

---

### 8. Settings Panel Integration

**Location:** Modify `src/components/SettingsPanel/`

Add a new "Plugins" tab:
```tsx
// In SettingsPanel tabs
{
  id: 'plugins',
  label: 'Plugins',
  icon: <PluginIcon />,
  content: <PluginManager />,
}
```

---

## File Structure

```
src/components/
├── PluginBrowser/
│   ├── index.tsx
│   ├── PluginBrowser.module.css
│   ├── PluginFilters.tsx
│   └── PluginSearch.tsx
├── PluginCard/
│   ├── index.tsx
│   └── PluginCard.module.css
├── PluginDetails/
│   ├── index.tsx
│   ├── PluginDetails.module.css
│   ├── PluginScreenshots.tsx
│   └── PluginCapabilities.tsx
├── PluginManager/
│   ├── index.tsx
│   ├── PluginManager.module.css
│   ├── InstalledPluginRow.tsx
│   └── PluginSettings.tsx
└── PluginPermissionDialog/
    ├── index.tsx
    ├── PluginPermissionDialog.module.css
    └── CapabilityItem.tsx

src/plugins/
├── registry/
│   └── registryClient.ts
└── hooks/
    ├── usePlugins.ts
    └── useInstallPlugin.ts
```

---

## Testing Requirements

Create tests in `tests/components/`:
- `PluginBrowser.test.tsx` - Browser functionality
- `PluginCard.test.tsx` - Card display
- `PluginManager.test.tsx` - Management actions
- `PluginPermissionDialog.test.tsx` - Permission handling

---

## Success Criteria

- [ ] Plugin browser displays plugins from registry
- [ ] Search and filter work correctly
- [ ] Plugin details show full information
- [ ] Plugin manager lists installed plugins
- [ ] Enable/disable toggles work
- [ ] Uninstall removes plugins
- [ ] Permission dialogue shows for high-risk capabilities
- [ ] Plugins tab added to settings panel
- [ ] All components are accessible (keyboard, screen reader)
- [ ] All tests pass

---

## Notes

- Follow existing component patterns in the codebase
- Use existing Modal, Button, Badge components where available
- Ensure responsive design for all components
- Use British English in all user-facing text
