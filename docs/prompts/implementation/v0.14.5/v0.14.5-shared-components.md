# v0.14.5 Work Package: Shared Mechanics Components

## Overview

Extract duplicated UI patterns from game mechanics into a shared component library, then refactor all existing mechanics to use the shared components.

**Version:** v0.14.5
**Dependencies:** v0.14.0 complete
**Estimated Scope:** ~400 new lines, ~600 lines removed (net reduction)

---

## Context

After v0.14.0, itemdeck has five game mechanics:
- Memory (`src/mechanics/memory/`)
- Snap Ranking (`src/mechanics/snap-ranking/`)
- Competing (`src/mechanics/competing/`)
- Quiz (`src/mechanics/quiz/`)
- Collection (`src/mechanics/collection/`)

Each mechanic independently implements:
- Floating timer (during gameplay)
- Completion/results modal
- Error overlay
- Action buttons (Exit, Play Again, Choose Different)
- Modal styling CSS

This creates maintenance burden and inconsistency.

---

## Objectives

1. Create shared component library at `src/mechanics/shared/`
2. Extract FloatingTimer, GameCompletionModal, ErrorOverlay
3. Create useMechanicActions hook
4. Consolidate CSS into shared.module.css
5. Refactor all five mechanics to use shared components
6. Reduce each mechanic's components.tsx to < 150 lines

---

## Technical Requirements

### 1. Directory Structure

Create the following structure:

```
src/mechanics/shared/
‚îú‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ FloatingTimer.tsx
‚îÇ   ‚îú‚îÄ‚îÄ GameCompletionModal.tsx
‚îÇ   ‚îú‚îÄ‚îÄ ErrorOverlay.tsx
‚îÇ   ‚îî‚îÄ‚îÄ ActionButtonGroup.tsx
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ useGameTimer.ts
‚îÇ   ‚îî‚îÄ‚îÄ useMechanicActions.ts
‚îî‚îÄ‚îÄ shared.module.css
```

---

### 2. FloatingTimer Component

**Location:** `src/mechanics/shared/components/FloatingTimer.tsx`

**Purpose:** Display elapsed time and progress during active gameplay.

**Props:**
```typescript
interface FloatingTimerProps {
  /** Elapsed time in milliseconds */
  timeMs: number;
  /** Progress indicator text (e.g., "5/10", "45%") */
  progressLabel?: string;
  /** Whether to show the timer */
  visible: boolean;
  /** Optional className for customisation */
  className?: string;
}
```

**Implementation:**
```typescript
import { AnimatePresence, motion } from "framer-motion";
import styles from "../shared.module.css";

function formatTime(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${String(minutes).padStart(2, "0")}:${String(remainingSeconds).padStart(2, "0")}`;
}

export function FloatingTimer({
  timeMs,
  progressLabel,
  visible,
  className,
}: FloatingTimerProps) {
  return (
    <AnimatePresence>
      {visible && (
        <motion.div
          className={`${styles.floatingTimer} ${className ?? ""}`}
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -10 }}
        >
          <span className={styles.timerIcon}>‚è±</span>
          <span className={styles.timerValue}>{formatTime(timeMs)}</span>
          {progressLabel && (
            <span className={styles.progress}>{progressLabel}</span>
          )}
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

---

### 3. GameCompletionModal Component

**Location:** `src/mechanics/shared/components/GameCompletionModal.tsx`

**Purpose:** Display game results with consistent styling across mechanics.

**Props:**
```typescript
interface StatItem {
  label: string;
  value: string | number;
}

interface ActionButton {
  label: string;
  onClick: () => void;
}

interface GameCompletionModalProps {
  /** Whether modal is visible */
  isOpen: boolean;
  /** Modal title (e.g., "Complete!", "Game Over!") */
  title: string;
  /** Optional subtitle/summary text */
  subtitle?: string;
  /** Array of stat items to display */
  stats: StatItem[];
  /** Primary action button */
  primaryAction: ActionButton;
  /** Secondary action button (optional) */
  secondaryAction?: ActionButton;
  /** Exit handler */
  onExit: () => void;
  /** Exit button label (default: "Exit") */
  exitLabel?: string;
  /** Custom content below stats */
  children?: ReactNode;
}
```

**Implementation Notes:**
- Use AnimatePresence with scale/opacity animation
- Stats displayed in grid layout
- Action buttons follow standard hierarchy (primary filled, secondary outline, exit text)
- Support custom children for mechanic-specific content (e.g., guess breakdown)

**Example Implementation:**
```typescript
import type { ReactNode } from "react";
import { AnimatePresence, motion } from "framer-motion";
import styles from "../shared.module.css";

interface StatItem {
  label: string;
  value: string | number;
}

interface ActionButton {
  label: string;
  onClick: () => void;
}

export interface GameCompletionModalProps {
  isOpen: boolean;
  title: string;
  subtitle?: string;
  stats: StatItem[];
  primaryAction: ActionButton;
  secondaryAction?: ActionButton;
  onExit: () => void;
  exitLabel?: string;
  children?: ReactNode;
}

export function GameCompletionModal({
  isOpen,
  title,
  subtitle,
  stats,
  primaryAction,
  secondaryAction,
  onExit,
  exitLabel = "Exit",
  children,
}: GameCompletionModalProps) {
  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className={styles.modalOverlay}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <motion.div
            className={styles.modalContent}
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
          >
            <h2 className={styles.modalTitle}>{title}</h2>

            {subtitle && (
              <p className={styles.modalSubtitle}>{subtitle}</p>
            )}

            <div className={styles.statsGrid}>
              {stats.map((stat) => (
                <div key={stat.label} className={styles.statItem}>
                  <span className={styles.statLabel}>{stat.label}</span>
                  <span className={styles.statValue}>{stat.value}</span>
                </div>
              ))}
            </div>

            {children}

            <div className={styles.actionButtons}>
              <button
                type="button"
                className={styles.exitButton}
                onClick={onExit}
              >
                {exitLabel}
              </button>
              {secondaryAction && (
                <button
                  type="button"
                  className={styles.secondaryButton}
                  onClick={secondaryAction.onClick}
                >
                  {secondaryAction.label}
                </button>
              )}
              <button
                type="button"
                className={styles.primaryButton}
                onClick={primaryAction.onClick}
              >
                {primaryAction.label}
              </button>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

---

### 4. ErrorOverlay Component

**Location:** `src/mechanics/shared/components/ErrorOverlay.tsx`

**Purpose:** Display error state when mechanic cannot operate.

**Props:**
```typescript
export interface ErrorOverlayProps {
  /** Error title */
  title: string;
  /** Error message */
  message: string;
  /** Hint text (optional) */
  hint?: string;
  /** Exit handler */
  onExit: () => void;
  /** Whether overlay is visible */
  visible: boolean;
}
```

**Implementation:**
```typescript
import { AnimatePresence, motion } from "framer-motion";
import styles from "../shared.module.css";

export interface ErrorOverlayProps {
  title: string;
  message: string;
  hint?: string;
  onExit: () => void;
  visible: boolean;
}

export function ErrorOverlay({
  title,
  message,
  hint,
  onExit,
  visible,
}: ErrorOverlayProps) {
  return (
    <AnimatePresence>
      {visible && (
        <motion.div
          className={styles.errorOverlay}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <motion.div
            className={styles.errorModal}
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
          >
            <h2 className={styles.errorTitle}>{title}</h2>
            <p className={styles.errorMessage}>{message}</p>
            {hint && <p className={styles.errorHint}>{hint}</p>}
            <button
              type="button"
              className={styles.primaryButton}
              onClick={onExit}
            >
              Exit
            </button>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

---

### 5. useMechanicActions Hook

**Location:** `src/mechanics/shared/hooks/useMechanicActions.ts`

**Purpose:** Provide standard action handlers used by all game mechanics.

**Implementation:**
```typescript
import { useCallback } from "react";
import { useMechanicContext } from "../../context";

export interface UseMechanicActionsResult {
  /** Deactivate current mechanic */
  handleExit: () => void;
  /** Deactivate and open mechanic panel */
  handlePlayAgain: () => void;
  /** Deactivate and open mechanic panel */
  handleChooseDifferent: () => void;
}

export function useMechanicActions(): UseMechanicActionsResult {
  const { deactivateMechanic, openMechanicPanel } = useMechanicContext();

  const handleExit = useCallback(() => {
    deactivateMechanic();
  }, [deactivateMechanic]);

  const handlePlayAgain = useCallback(() => {
    deactivateMechanic();
    openMechanicPanel();
  }, [deactivateMechanic, openMechanicPanel]);

  const handleChooseDifferent = useCallback(() => {
    deactivateMechanic();
    openMechanicPanel();
  }, [deactivateMechanic, openMechanicPanel]);

  return { handleExit, handlePlayAgain, handleChooseDifferent };
}
```

---

### 6. useGameTimer Hook

**Location:** `src/mechanics/shared/hooks/useGameTimer.ts`

**Purpose:** Handle timer state and tick updates.

**Implementation:**
```typescript
import { useState, useEffect } from "react";

export interface UseGameTimerOptions {
  /** Whether timer is running */
  isRunning: boolean;
  /** Start timestamp (ms) */
  startTime: number | null;
  /** End timestamp (ms) - stops timer updates */
  endTime?: number | null;
}

export interface UseGameTimerResult {
  /** Elapsed time in milliseconds */
  elapsedMs: number;
  /** Formatted time string (MM:SS) */
  formattedTime: string;
}

function formatTime(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${String(minutes).padStart(2, "0")}:${String(remainingSeconds).padStart(2, "0")}`;
}

export function useGameTimer({
  isRunning,
  startTime,
  endTime,
}: UseGameTimerOptions): UseGameTimerResult {
  const [tick, setTick] = useState(0);

  useEffect(() => {
    if (!isRunning || !startTime) return;

    const interval = setInterval(() => {
      setTick((t) => t + 1);
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, [isRunning, startTime]);

  const endTimestamp = endTime ?? Date.now();
  const elapsedMs = startTime ? endTimestamp - startTime : 0;
  const formattedTime = formatTime(elapsedMs);

  return { elapsedMs, formattedTime };
}
```

---

### 7. Shared CSS Module

**Location:** `src/mechanics/shared/shared.module.css`

```css
/* Floating Timer */
.floatingTimer {
  position: fixed;
  top: calc(0.75rem + env(safe-area-inset-top, 0px));
  right: calc(0.75rem + env(safe-area-inset-right, 0px));
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;
  background: var(--colour-surface);
  border: 1px solid var(--colour-border);
  border-radius: var(--border-radius);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.timerIcon {
  font-size: 1rem;
}

.timerValue {
  font-variant-numeric: tabular-nums;
  font-weight: 500;
  colour: var(--colour-text);
}

.progress {
  colour: var(--colour-text-muted);
  font-size: 0.875rem;
}

/* Modal Overlay */
.modalOverlay {
  position: fixed;
  inset: 0;
  z-index: 200;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.75);
  padding: 1rem;
}

.modalContent {
  background: var(--colour-surface);
  border-radius: var(--border-radius-lg);
  padding: 1.5rem;
  max-width: 400px;
  width: 100%;
  max-height: 80vh;
  overflow-y: auto;
}

.modalTitle {
  font-size: 1.5rem;
  font-weight: 600;
  text-align: center;
  margin-bottom: 0.5rem;
}

.modalSubtitle {
  text-align: center;
  colour: var(--colour-text-muted);
  margin-bottom: 1rem;
}

/* Stats Grid */
.statsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
  gap: 0.75rem;
  margin-bottom: 1.5rem;
}

.statItem {
  text-align: center;
}

.statLabel {
  display: block;
  font-size: 0.75rem;
  colour: var(--colour-text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 0.25rem;
}

.statValue {
  display: block;
  font-size: 1.25rem;
  font-weight: 600;
}

/* Action Buttons */
.actionButtons {
  display: flex;
  gap: 0.75rem;
  justify-content: center;
  flex-wrap: wrap;
}

.primaryButton {
  background: var(--colour-primary);
  colour: var(--colour-text-on-primary, #fff);
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: var(--border-radius);
  font-weight: 500;
  cursor: pointer;
  transition: opacity 0.2s;
}

.primaryButton:hover {
  opacity: 0.9;
}

.primaryButton:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.secondaryButton {
  background: transparent;
  colour: var(--colour-text);
  border: 1px solid var(--colour-border);
  padding: 0.75rem 1.5rem;
  border-radius: var(--border-radius);
  font-weight: 500;
  cursor: pointer;
  transition: background-colour 0.2s;
}

.secondaryButton:hover {
  background: var(--colour-surface-hover);
}

.secondaryButton:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.exitButton {
  background: none;
  border: none;
  colour: var(--colour-text-muted);
  padding: 0.5rem 1rem;
  cursor: pointer;
  text-decoration: underline;
  text-underline-offset: 2px;
}

.exitButton:hover {
  colour: var(--colour-text);
}

/* Error Overlay */
.errorOverlay {
  position: fixed;
  inset: 0;
  z-index: 200;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.75);
  padding: 1rem;
}

.errorModal {
  background: var(--colour-surface);
  border-radius: var(--border-radius-lg);
  padding: 1.5rem;
  max-width: 400px;
  width: 100%;
  text-align: center;
}

.errorTitle {
  font-size: 1.25rem;
  font-weight: 600;
  colour: var(--colour-error, #ef4444);
  margin-bottom: 0.75rem;
}

.errorMessage {
  colour: var(--colour-text);
  margin-bottom: 0.5rem;
}

.errorHint {
  colour: var(--colour-text-muted);
  font-size: 0.875rem;
  margin-bottom: 1rem;
}

/* Responsive Adjustments */
@media (max-width: 480px) {
  .floatingTimer {
    top: calc(0.5rem + env(safe-area-inset-top, 0px));
    right: calc(0.5rem + env(safe-area-inset-right, 0px));
    padding: 0.375rem 0.5rem;
    font-size: 0.875rem;
  }

  .modalContent {
    padding: 1rem;
    max-width: calc(100% - 2rem);
  }

  .actionButtons {
    flex-direction: column;
  }

  .primaryButton,
  .secondaryButton {
    width: 100%;
  }
}
```

---

### 8. Barrel Exports

**src/mechanics/shared/index.ts:**
```typescript
export * from "./components";
export * from "./hooks";
```

**src/mechanics/shared/components/index.ts:**
```typescript
export { FloatingTimer } from "./FloatingTimer";
export type { FloatingTimerProps } from "./FloatingTimer";
export { GameCompletionModal } from "./GameCompletionModal";
export type { GameCompletionModalProps } from "./GameCompletionModal";
export { ErrorOverlay } from "./ErrorOverlay";
export type { ErrorOverlayProps } from "./ErrorOverlay";
```

**src/mechanics/shared/hooks/index.ts:**
```typescript
export { useMechanicActions } from "./useMechanicActions";
export type { UseMechanicActionsResult } from "./useMechanicActions";
export { useGameTimer } from "./useGameTimer";
export type { UseGameTimerOptions, UseGameTimerResult } from "./useGameTimer";
```

---

## Refactoring Guide

### Memory Mechanic Refactor

**Before:** `src/mechanics/memory/components.tsx` (~233 lines)

**After:** (~80 lines)

```typescript
import { AnimatePresence, motion } from "framer-motion";
import { FloatingTimer, GameCompletionModal } from "../shared";
import { useMechanicActions, useGameTimer } from "../shared/hooks";
import { useMemoryStore } from "./store";
import type { CardOverlayProps, GridOverlayProps } from "../types";
import styles from "./memory.module.css";

/**
 * Card overlay for memory game.
 * Shows match/selection indicators.
 */
export function MemoryCardOverlay({ cardId }: CardOverlayProps) {
  // Keep existing card overlay logic unchanged
  const visibleCards = useMemoryStore((s) => s.visibleCards);
  const matchedPairs = useMemoryStore((s) => s.matchedPairs);
  const firstCard = useMemoryStore((s) => s.firstCard);
  const phase = useMemoryStore((s) => s.phase);

  const isFlipped = visibleCards.includes(cardId);
  const isMatched = matchedPairs.some((pair) => pair.includes(cardId));
  const isHiddenFirstCard = firstCard === cardId &&
    !visibleCards.includes(cardId) &&
    phase === "first_selected";

  return (
    <AnimatePresence>
      {isMatched && (
        <motion.div
          className={styles.matchedOverlay}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <span className={styles.matchedIcon}>‚úì</span>
        </motion.div>
      )}
      {isFlipped && !isMatched && (
        <motion.div
          className={styles.selectedOverlay}
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          exit={{ scale: 0.8, opacity: 0 }}
        />
      )}
      {isHiddenFirstCard && (
        <motion.div
          className={styles.firstCardIndicator}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        />
      )}
    </AnimatePresence>
  );
}

/**
 * Grid overlay for memory game.
 * Shows floating timer during play, completion modal when done.
 */
export function MemoryGridOverlay({ position }: GridOverlayProps) {
  const isComplete = useMemoryStore((s) => s.isComplete);
  const score = useMemoryStore((s) => s.score);
  const attempts = useMemoryStore((s) => s.attempts);
  const matchedPairs = useMemoryStore((s) => s.matchedPairs);
  const cardIds = useMemoryStore((s) => s.cardIds);
  const startTime = useMemoryStore((s) => s.startTime);
  const endTime = useMemoryStore((s) => s.endTime);

  const { handleExit, handlePlayAgain } = useMechanicActions();
  const { elapsedMs, formattedTime } = useGameTimer({
    isRunning: !isComplete && startTime !== null,
    startTime,
    endTime,
  });

  const totalPairs = Math.floor(cardIds.length / 2);
  const foundPairs = matchedPairs.length;
  const isActivePlay = startTime !== null && !isComplete;

  if (position === "top") {
    return (
      <FloatingTimer
        timeMs={elapsedMs}
        progressLabel={`${foundPairs}/${totalPairs}`}
        visible={isActivePlay}
      />
    );
  }

  return (
    <GameCompletionModal
      isOpen={isComplete}
      title="üéâ Complete!"
      subtitle={`You found all ${totalPairs} pairs in ${attempts} attempts!`}
      stats={[
        { label: "Pairs", value: `${foundPairs}/${totalPairs}` },
        { label: "Attempts", value: attempts },
        { label: "Score", value: score },
        { label: "Time", value: formattedTime },
      ]}
      primaryAction={{ label: "Play Again", onClick: handlePlayAgain }}
      secondaryAction={{ label: "Choose Different", onClick: handlePlayAgain }}
      onExit={handleExit}
    />
  );
}
```

### Snap Ranking Refactor

Similar pattern - replace:
- `FloatingTimer` component with shared version
- `ResultsModal` component with `GameCompletionModal`
- `ErrorOverlay` component with shared version
- Action handlers with `useMechanicActions` hook
- Timer logic with `useGameTimer` hook

Keep mechanic-specific components:
- `GuessButtons` (unique to snap ranking)
- `SnapRankingCardOverlay` (unique guess badges)

### Competing, Quiz, Collection

When implementing v0.14.0 mechanics, import from shared instead of duplicating:

```typescript
import { FloatingTimer, GameCompletionModal, ErrorOverlay } from "../shared";
import { useMechanicActions, useGameTimer } from "../shared/hooks";
```

---

## Testing Requirements

### Unit Tests

**src/mechanics/shared/__tests__/FloatingTimer.test.tsx:**
```typescript
describe("FloatingTimer", () => {
  it("renders when visible=true", () => {});
  it("hidden when visible=false", () => {});
  it("formats time correctly (0ms -> 00:00)", () => {});
  it("formats time correctly (65000ms -> 01:05)", () => {});
  it("shows progress label when provided", () => {});
  it("hides progress label when not provided", () => {});
});
```

**src/mechanics/shared/__tests__/GameCompletionModal.test.tsx:**
```typescript
describe("GameCompletionModal", () => {
  it("renders when isOpen=true", () => {});
  it("hidden when isOpen=false", () => {});
  it("displays title", () => {});
  it("displays subtitle when provided", () => {});
  it("displays all stats", () => {});
  it("calls primaryAction.onClick when primary button clicked", () => {});
  it("calls secondaryAction.onClick when secondary button clicked", () => {});
  it("hides secondary button when secondaryAction not provided", () => {});
  it("calls onExit when exit button clicked", () => {});
  it("uses custom exitLabel when provided", () => {});
  it("renders children when provided", () => {});
});
```

**src/mechanics/shared/__tests__/ErrorOverlay.test.tsx:**
```typescript
describe("ErrorOverlay", () => {
  it("renders when visible=true", () => {});
  it("hidden when visible=false", () => {});
  it("displays title", () => {});
  it("displays message", () => {});
  it("displays hint when provided", () => {});
  it("hides hint when not provided", () => {});
  it("calls onExit when exit button clicked", () => {});
});
```

**src/mechanics/shared/__tests__/useMechanicActions.test.ts:**
```typescript
describe("useMechanicActions", () => {
  it("handleExit calls deactivateMechanic", () => {});
  it("handlePlayAgain calls deactivateMechanic then openMechanicPanel", () => {});
  it("handleChooseDifferent calls deactivateMechanic then openMechanicPanel", () => {});
});
```

**src/mechanics/shared/__tests__/useGameTimer.test.ts:**
```typescript
describe("useGameTimer", () => {
  it("returns 0 elapsed when startTime is null", () => {});
  it("calculates elapsed time correctly", () => {});
  it("uses endTime when provided", () => {});
  it("uses current time when endTime not provided", () => {});
  it("formats time correctly", () => {});
  it("updates every second when isRunning", () => {});
  it("stops updating when isRunning becomes false", () => {});
});
```

### Integration Tests

- Memory mechanic still works after refactor
- Snap Ranking mechanic still works after refactor
- All game mechanics have consistent completion modal styling
- Timer displays correctly across all mechanics

---

## Success Criteria

- [ ] `src/mechanics/shared/` directory created with all components
- [ ] FloatingTimer used by all game mechanics
- [ ] GameCompletionModal used by Memory, Snap, Competing, Quiz
- [ ] ErrorOverlay used by all mechanics with error states
- [ ] useMechanicActions hook used by all mechanics
- [ ] useGameTimer hook used by all timed mechanics
- [ ] Memory components.tsx < 100 lines
- [ ] Snap Ranking components.tsx < 150 lines
- [ ] No duplicate timer formatting code
- [ ] No duplicate modal CSS
- [ ] Consistent styling across all mechanics
- [ ] All tests passing
- [ ] TypeScript strict mode compliant
- [ ] British English in all user-facing text

---

## Notes

- Do not change mechanic-specific logic (card overlays, game rules)
- Only extract UI patterns that are duplicated
- Preserve animation behaviour (AnimatePresence, motion)
- Use CSS custom properties for theme compatibility
- Collection mechanic may not need completion modal (not a game)
- Keep mechanic-specific CSS in their own modules (e.g., memory.module.css)

---

## Related Documentation

- [v0.14.5 Milestone](../../../development/roadmap/milestones/v0.14.5.md)
- [v0.14.0 Milestone](../../../development/roadmap/milestones/v0.14.0.md)
- [Memory Mechanic](../../../../src/mechanics/memory/)
- [Snap Ranking Mechanic](../../../../src/mechanics/snap-ranking/)
- [Mechanic Types](../../../../src/mechanics/types.ts)
